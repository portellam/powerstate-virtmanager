/*
  ui_xml.h is generated by running make. It can be targeted specifically with
  `make source/ui_xml.h`
*/

#include "data.h"
#include "version.h"
#include <gtk/gtk.h>
#include <stdlib.h>

/*
  The macros VERSION, NAME, TARGET, AUTHOR and COPYRIGHT are available for this
  program to reference
  information about itself. These macros are defined in config.mk
*/

/*
  Main
*/
  int main(int argc, char* argv[])
  {
    if (
          argc >= 2
          && (
            0 == strcmp (argv[1], "--version")
          || 0 == strcmp (argv[1], "-v")
    ))
    {
      version();
    }

    GtkBuilder* builder;
    GtkWidget*  window;

    gtk_init (
      &argc,
      &argv
    );

    builder = gtk_builder_new_from_resource (APP_PREFIX"/window_main.glade");

    window = GTK_WIDGET (gtk_builder_get_object (
        builder,
        "window_main"
    ));

    gtk_builder_connect_signals(
      builder,
      NULL
    );

    g_object_unref (builder);

    gtk_widget_show (window);
    gtk_main ();
    return 0;
  }

/*
  Shell logic
*/
  //int run_command (char* argv[])
  bool run_command (char* command)
  {
    int status = system(command);
    return status == 0;
  }

  char* get_virsh_command (char* option)
  {
    if (
      option == NULL
      || strcmp(option, "")
    )
    {
      return "";
    }

    return "sudo virsh " + option;
  }

  char* get_virsh_command (char* option, char* domain)
  {
    if (
      option == NULL
      || strcmp(option, "")
    )
    {
      return "";
    }

    if (
      domain == NULL
      || strcmp(domain, "")
    )
    {
      return "";
    }

    return "sudo virsh " + option + " --domain " + domain;
  }

/*
  Getter logic
*/
  char*[] get_domain_list ()
  {
    char* get_delim="arr=$( sudo virsh list --name --all | head )'; echo $arr"
    char delimiter = " ";
    char* domain_delim = run_command (get_delim);

    size_t delim_count = count_char_in_string (domain_delim, delimiter);
    char* domain_list [delim_count];

    size_t index = 0;

    while (domain_delim[index])
    {
      size_t delim_index = domain_delim.find (delimiter);

      char* domain = domain_delim.substr(
        index,
        domain_delim.find (delim_index)
      );

      domain_list [index] = domain;

      size_t last_index = strlen (domain_delim) - 1;

      domain_delim = domain_delim.substr(
        delim_index,
        last_index
      )

      index++;
    }

    return domain_list;
  }

  int count_char_in_string(char* string, char _char)
  {
    int count = 0;

    for (int i = 0; i < strlen(string); i++)
    {
      if (s[i] != c)
      {
        continue
      }

      count++
    }

    return count;
  }

/*
  Domain operation and validation logic
*/
  bool domain_exists (char* domain)
  {
    if (
      domain == NULL
      || strcmp(domain, "")
    )
    {
      return 1;
    }

    char* command = get_virsh_command ("list --name");
    command += "| grep --fixed-strings --line-regexp \"%s\" ", domain;
    command += "| head --lines 1";
    return run_command (command);
  }

  bool domain_start (char* domain)
  {
    char* state = get_domain_state (domain);
    char* option = "";

    switch (state)
    {
      case "running":
        return false;

      case "paused":
        option = "resume";
        break;

      case "pmsuspended":
        option = "dompmwakeup";
        break;

      case "shut off":
        option = "start";
        break;

      default:
        return false;
    }

    char* command = get_virsh_command (option, domain);
    return run_command (command);
  }

  bool domain_pause (char* domain)
  {
    char* state = get_domain_state (domain);
    char* option = "";

    switch (state)
    {
      case "running":
        option = "pause";
        break;

      default:
        return false;
    }

    char* command = get_virsh_command (option, domain);
    return run_command (command);
  }

  bool domain_sleep (char* domain)
  {
    char* state = get_domain_state (domain);
    char* option = "";

    switch (state)
    {
      case "running":
        option = "dompmsuspend --target mem";
        break;

      default:
        return false;
    }

    char* command = get_virsh_command (option, domain);
    return run_command (command);
  }

  bool domain_hibernate (char* domain)
  {
    char* state = get_domain_state (domain);
    char* option = "";

    switch (state)
    {
      case "running":
        option = "dompmsuspend --target disk";
        break;

      default:
        return false;
    }

    char* command = get_virsh_command (option, domain);
    return run_command (command);
  }

  bool domain_hybrid_sleep (char* domain)
  {
    char* state = get_domain_state (domain);
    char* option = "";

    switch (state)
    {
      case "running":
        option = "dompmsuspend --target hybrid";
        break;

      default:
        return false;
    }

    char* command = get_virsh_command (option, domain);
    return run_command (command);
  }

  bool domain_restart (char* domain)
  {
    char* state = get_domain_state (domain);
    char* option = "";

    switch (state)
    {
      case "running":
        option = "reboot";
        break;

      default:
        return false;
    }

    char* command = get_virsh_command (option, domain);
    return run_command (command);
  }

  bool domain_reset (char* domain)
  {
    char* state = get_domain_state (domain);
    char* option = "";

    switch (state)
    {
      case "running":
        option = "reset";
        break;

      default:
        return false;
    }

    char* command = get_virsh_command (option, domain);
    return run_command (command);
  }

  bool domain_stop (char* domain)
  {
    char* state = get_domain_state (domain);
    char* option = "";

    switch (state)
    {
      case "running":
        option = "shutdown";
        break;

      default:
        return false;
    }

    char* command = get_virsh_command (option, domain);
    return run_command (command);
  }

  bool domain_force_stop (char* domain)
  {
    char* state = get_domain_state (domain);
    char* option = "";

    switch (state)
    {
      case "running":
        option = "destroy";
        break;

      default:
        return false;
    }

    char* command = get_virsh_command (option, domain);
    return run_command (command);
  }

  char* get_domain_state (char* domain)
  {
    if (! domain_exists (domain))
    {
      return;
    }

    return "sudo virsh domstate %s  | head --lines 1", domain;
  }

/*
  Presentation logic
*/
  void on_window_main_destroy ()
  {
    gtk_main_quit ();
  }